# 题目链接
https://leetcode-cn.com/problems/merge-two-sorted-lists/
# 解题思路
## 方法1：迭代 
（1）引入哨兵节点（即哑节点），初始值为-1（多少都不重要，因为我们不会返回这个值），指针prev；   
（2）当l1和l2都不为空时，比较其首数个数据大小，如果了l1较小，则把了l1替换成prev->next（prev->next=l1;），同时，
l1往后移一位（l1=l1->next;）；反之，则替换成来l2；
（3）当比较完成之后，最多只有一个链表是非空的（原因是两个链表长度不相等），就判断哪个是非空的：如果是l1，则把链表接在l1后面，  
反之，则接在l2后面
（4）返回preHead后面的值即可（这个时候prev已经跑远了，别再返回prev和prev->next了）。
# 代码部分
```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        //方法1：迭代
       ListNode* preHead =new ListNode(-1);
        ListNode* prev = preHead;
        while(l1!=nullptr&&l2!=nullptr)
        {
            if(l1->val<l2->val)
            {
                prev->next=l1;
                l1=l1->next;
            }
            else{
                prev->next=l2;
                l2=l2->next;
            }
            prev=prev->next;
        }
        prev->next=l1==nullptr? l2:l1;
        return preHead->next;
     
        
    }
};
```
# 复杂度分析
时间复杂度：*O*（m+n）不会超过两个链表的长度之和，其中m和n分别指l1和l2的长度；   
空间复杂度：*O*（1），因为只占用常数空间
